---
title: "Ã‰tude du F-test (Snedecor's F-distribution)"
author: "Alexandre Personnic"
date: "November-December 2022"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Theorical construction of the F-Test

First, we define the test statistic we are foing to use. 

Following the observations from Barlow et al (1972, p. 197), we decided to
divide the failure times in two parts, the first $d$ and the last $n-d$, and to
use the statistic $F=(n-d)T_d/(d(T_n-T_d))$ for the test.

Taking $d=\left\lfloor\dfrac{n}{2}\right\rfloor$, if the intensity is
increasing, $T_n - T_d$ should be smaller than for a constant intensity.
Hence an increasing intensity should correspond to a larger value of this ratio.

The random variable $T_d$ (resp. $T_n-T_d$) follows a Gamma distribution with parameters $n$
and $\lambda$ (resp. $n-d$ and $\lambda$). As such, $F$ follows a Snedecor's F-distribution
with $2d$ and $2(n-d)$ degrees of freedom.

### Simulation with homogeneous poisson processs

We simulate homogeneous Poisson processes with given intensity $\lambda$. 

```{r,eval=TRUE}
simulPPh1 <- function(lambda, Tmax) {
  Y <- rpois(1, lambda * Tmax)
  U <- runif(Y, min = 0, max = Tmax)
  return(sort(U))
}
```

```{r,eval=TRUE}
# simulate a homogeneous Poisson process:
lambda <- 2
Tmax <- 20
PPh1 = simulPPh1(lambda, Tmax)


# plot the counting process (with jumps = 1): 
plot(c(0,PPh1),seq(0,length(PPh1)),type="s",xlab="time t",ylab="number of events by time t")

# add the arrival times: 
points(PPh1, rep(0,length(PPh1)),type="p")

# link the arrival times with the counts:
lines(PPh1, seq(1,length(PPh1)),type="h",lty=2)
```

```{r, eval=TRUE}
n = length(PPh1)
d = floor(n/2)
F = (n-d)*PPh1[d]/(d*(PPh1[n] - PPh1[d]))
alpha = 1. - pf(F, 2*d, 2*(n-d))
print(alpha)
```

```{r,eval=TRUE}
nb_miss = 0
alpha = 0.05
lambda = 2
nb_simul = 100000
Tmax = 20
for (i in 1:nb_simul) {
  PPh1 = simulPPh1(lambda, Tmax)
  n = length(PPh1)
  d = floor(n/2)
  F = (n-d)*PPh1[d]/(d*(PPh1[n] - PPh1[d]))
  p_val = 1. - pf(F, 2*d, 2*(n-d))
  if (p_val < alpha) {
    nb_miss = nb_miss + 1
  }
}
print(nb_miss/nb_simul)
```

### Simulation with in-homogeneous poisson processs

We simulate inhomogeneous Poisson processes with given intensity function on a fixed window and 
with an affine intensity function. 

```{r, eval=TRUE}
# lambda increasing by level 1 -> 4 -> 8
lambda_fct1 <- function(t) {
  return(ifelse(t <= 5, 1, 
                ifelse(t <= 10, 4, 8)))
}
# Tmax=20
# s <- seq(from=0, to=Tmax, length.out=100)
# ti <- c()
# for (i in s) {
#   ti <- c(ti, lambda_fct1(i))
# }
# plot(s, ti)
```

```{r,eval=TRUE}
# return lambda affine function of t with origin and coefficient
lambda_affine <- function(origin=0, coef=1) {
  if(coef == 0) {
    stop("coef must not be 0.")
  }
  temp_fun <- function(t) {
    return(origin+t*coef)
  }
  return(temp_fun)
}
# lambda_lin = lambda_affine(1, 1/5)
# ti <- c()
# for (i in s) {
#   ti <- c(ti, lambda_lin(i))
# }
# plot(s, ti)
```

```{r, eval=True}
invert_LAMBDA_affine <- function(origin=0, coef=1) {
  if(coef == 0) {
    stop("coef must not be 0.")
  }
  temp_fun <- function(K) {
    return((origin+sqrt(origin**2+coef*K))/coef)
  }
  return(temp_fun)
}
```

```{r,eval=TRUE}
# Processus to simulate an inhomogeneous poisson process
# with a given lambda function and y
simulPPi = function(lambda_fct,Tmax) {
  M = 1.2 * lambda_fct(Tmax)
  Ti <- simulPPh1(M, Tmax)
  n <- length(Ti)
  U <- runif(n, min = 0, max = M)
  ti <- c()
  for (i in 1:n){
    if (U[i] < lambda_fct(Ti[i])) {
      ti <- c(ti, Ti[i])
    }
  }
  return(sort(ti))
}
```

```{r, eval=TRUE}
simulPPi_jo <- function(lambda_fct, Tstar, invert_lambda_fct) {
  L_Tstar = lambda_fct(Tstar)
  # simulate the number of event under a Poisson distribution
  N <- rpois(1, L_Tstar)
  # simulate a uniform sample
  U <- runif(N,0,1)
  # apply the invert of the lambda function to get 
  S <- invert_lambda_fct(L_Tstar*U)
  # sort the sample
  return(sort(S)[1:N])
}
```


```{r,eval=FALSE}
Tmax=20
origin = 1
coef = 1/10

PPi1 = simulPPi(lambda_affine(origin, coef), Tmax)

# plot the counting process (with jumps = 1): 
plot(c(0,PPi1),seq(0,length(PPi1)),type="s",xlab="time t",ylab="number of events by time t")

# add the arrival times: 
points(PPi1, rep(0,length(PPi1)),type="p")

# link the arrival times with the counts:
lines(PPi1, seq(1,length(PPi1)),type="h",lty=2)
```

```{r, eval=TRUE}
n = length(PPi1)
d = floor(n/2)
F = (n-d)*PPi1[d]/(d*(PPi1[n] - PPi1[d]))
alpha = 1. - pf(F, 2*d, 2*(n-d))
print(alpha)
```

```{r,eval=TRUE}
nb_correct = 0
alpha = 0.05
nb_simul = 10000
origin = 1
coef = 1
Tmax = 20
for (i in 1:nb_simul) {
  PPi1 = simulPPi(lambda_affine(origin, coef), Tmax)
  n = length(PPi1)
  d = floor(n/2)
  F = (n-d)*PPi1[d]/(d*(PPi1[n] - PPi1[d]))
  p_val = 1. - pf(F, 2*d, 2*(n-d))
  if (p_val < alpha) {
    nb_correct = nb_correct + 1
  }
}
print(nb_correct)
```

```{r,eval=FALSE}
origin = 0
coef = 2

PPi2 = simulPPi(lambda_affine(origin, coef), Tmax)

# plot the counting process (with jumps = 1): 
plot(c(0,PPi2),seq(0,length(PPi2)),type="s",xlab="time t",ylab="number of events by time t")

# add the arrival times: 
points(PPi2, rep(0,length(PPi2)),type="p")

# link the arrival times with the counts:
lines(PPi2, seq(1,length(PPi2)),type="h",lty=2)
```

```{r, eval=TRUE}
n = length(PPi2)
d = floor(n/2)
F = (n-d)*PPi2[d]/(d*(PPi2[n] - PPi2[d]))
alpha = 1. - pf(F, 2*d, 2*(n-d))
print(alpha)
```




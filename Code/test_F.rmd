---
title: "Ã‰tude du F-test (Snedecor's F-distribution)"
author: "Alexandre Personnic"
date: "November-December 2022"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Theorical construction of the F-Test

First, we define the test statistic we are foing to use. 

Following the observations from Barlow et al (1972, p. 197), we decided to
divide the failure times in two parts, the first $d$ and the last $n-d$, and to
use the statistic $F=(n-d)T_d/(d(T_n-T_d))$ for the test.

Taking $d=\left\lfloor\dfrac{n}{2}\right\rfloor$, if the intensity is
increasing, $T_n - T_d$ should be smaller than for a constant intensity.
Hence an increasing intensity should correspond to a larger value of this ratio.

The random variable $T_d$ (resp. $T_n-T_d$) follows a Gamma distribution with parameters $n$
and $\lambda$ (resp. $n-d$ and $\lambda$). As such, $F$ follows a Snedecor's F-distribution
with $2d$ and $2(n-d)$ degrees of freedom.

### Simulation with homogeneous poisson processs

We simulate homogeneous Poisson processes with given intensity $\lambda$. 

```{r,eval=TRUE}
simulPPh1 <- function(lambda, Tmax) {
  Y <- rpois(1, lambda * Tmax)
  U <- runif(Y, min = 0, max = Tmax)
  return(sort(U))
}
```

```{r,eval=TRUE}
# simulate a homogeneous Poisson process:
lambda <- 2
Tmax <- 20
PPh1 = simulPPh1(lambda, Tmax)


# plot the counting process (with jumps = 1): 
plot(c(0,PPh1),seq(0,length(PPh1)),type="s",xlab="time t",ylab="number of events by time t")

# add the arrival times: 
points(PPh1, rep(0,length(PPh1)),type="p")

# link the arrival times with the counts:
lines(PPh1, seq(1,length(PPh1)),type="h",lty=2)
```

```{r, eval=TRUE}
n = length(PPh1)
d = floor(n/2)
F = (n-d)*PPh1[d]/(d*(PPh1[n] - PPh1[d]))
alpha = 1. - pf(F, 2*d, 2*(n-d))
print(alpha)
```

### Simulation with in-homogeneous poisson processs

We simulate inhomogeneous Poisson processes with given intensity function on a fixed window and 
with an affine intensity function. 

```{r, eval=TRUE}
# lambda increasing by level 1 -> 4 -> 8
lambda_fct1 <- function(t) {
  return(ifelse(t <= 5, 1, 
                ifelse(t <= 10, 4, 8)))
}
# Tmax=20
# s <- seq(from=0, to=Tmax, length.out=100)
# ti <- c()
# for (i in s) {
#   ti <- c(ti, lambda_fct1(i))
# }
# plot(s, ti)
```

```{r,eval=TRUE}
# return lambda affine function of t with origin and coefficient
lambda_affine <- function(origin=1, coef=0) {
  lambda_lin <- function(t) {
    return(origin+t*coef)
  }
  return(lambda_lin)
}
# lambda_lin = lambda_affine(1, 1/5)
# ti <- c()
# for (i in s) {
#   ti <- c(ti, lambda_lin(i))
# }
# plot(s, ti)
```

```{r,eval=TRUE}
# Processus to simulate an inhomogeneous poisson process
# with a given lambda function and y
simulPPi = function(lambda_fct,Tmax) {
  M = 1.2 * lambda_fct(Tmax)
  Ti <- simulPPh1(M, Tmax)
  n <- length(Ti)
  U <- runif(n, min = 0, max = M)
  ti <- c()
  for (i in 1:n){
    if (U[i] < lambda_fct(Ti[i])) {
      ti <- c(ti, Ti[i])
    }
  }
  return(sort(ti))
}
```

```{r, eval=TRUE}
# How does it works ???
simulPPi_jo <- function(lambda_fct, Tstar){
  # simulate the number of event under a Poisson distribution
  N <- rpois(1, lambda_fct(Tstar))
  # simulate a uniform sample
  U <- runif(N,0,1)
  # apply the quantile function (inverse of the cumulative distribution function)
  S <- qf(U, Tstar)
  # sort the sample
  return(sort(S)[1:N])
}
```


```{r,eval=FALSE}
Tmax=20
origin = 1
coef = 1/10

PPi1 = simulPPi(lambda_affine(origin, coef), Tmax)

# plot the counting process (with jumps = 1): 
plot(c(0,PPi1),seq(0,length(PPi1)),type="s",xlab="time t",ylab="number of events by time t")

# add the arrival times: 
points(PPi1, rep(0,length(PPi1)),type="p")

# link the arrival times with the counts:
lines(PPi1, seq(1,length(PPi1)),type="h",lty=2)
```

```{r, eval=TRUE}
n = length(PPi1)
d = floor(n/2)
F = (n-d)*PPi1[d]/(d*(PPi1[n] - PPi1[d]))
alpha = 1. - pf(F, 2*d, 2*(n-d))
print(alpha)
```

```{r,eval=FALSE}
origin = 0
coef = 2

PPi2 = simulPPi(lambda_affine(origin, coef), Tmax)

# plot the counting process (with jumps = 1): 
plot(c(0,PPi2),seq(0,length(PPi2)),type="s",xlab="time t",ylab="number of events by time t")

# add the arrival times: 
points(PPi2, rep(0,length(PPi2)),type="p")

# link the arrival times with the counts:
lines(PPi2, seq(1,length(PPi2)),type="h",lty=2)
```

```{r, eval=TRUE}
n = length(PPi2)
d = floor(n/2)
F = (n-d)*PPi2[d]/(d*(PPi2[n] - PPi2[d]))
alpha = 1. - pf(F, 2*d, 2*(n-d))
print(alpha)
```



